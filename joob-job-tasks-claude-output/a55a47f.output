[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/index.jsx"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/signup.jsx"}
[Tool: Glob] {"pattern":"**/*.{js,jsx,ts,tsx}","path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile"}
[Tool: Glob] {"pattern":"**/*.{js,jsx,ts,tsx}","path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/constants/api.js"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/constants/colors.js"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/_layout.jsx"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/_layout.jsx"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/_layout.jsx"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/assets/styles/login.styles.js"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/assets/styles/signup.styles.js"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/assets/styles/signup.styles.js"}
[Tool: Bash] {"command":"ls -la /Users/hoangpham/dev/joob/","description":"List joob directory contents"}
[Tool: Glob] {"pattern":"**/mobile/auth/**/*.{ts,tsx,js,jsx}","path":"/Users/hoangpham/dev/joob"}
[Tool: Glob] {"pattern":"**/api/mobile/**/*.{ts,tsx,js,jsx}","path":"/Users/hoangpham/dev/joob"}
[Tool: Bash] {"command":"find /Users/hoangpham/dev/joob/app -type f -name \"*.ts\" -o -name \"*.tsx\" | grep -E \"(mobile|auth)\" | head -20","description":"Find mobile and auth related files in joob"}
[Tool: Bash] {"command":"find /Users/hoangpham/dev/joob/app/api -type d -name mobile","description":"Check for mobile API directory"}
[Tool: Bash] {"command":"find /Users/hoangpham/dev/joob/app/api -type d -name mobile","description":"Check for mobile API directory"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/joob/CLAUDE.md"}
[Tool: Bash] {"command":"ls -la /Users/hoangpham/dev/joob/app/api/","description":"List API directories in joob"}
[Tool: Bash] {"command":"ls -la /Users/hoangpham/dev/joob/app/api/","description":"List API directories in joob"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/joob/app/api/auth/register/route.ts"}
[Tool: Bash] {"command":"ls -la /Users/hoangpham/dev/joob/app/api/auth/","description":"List auth API endpoints"}
[Tool: Bash] {"command":"ls -la /Users/hoangpham/dev/joob/app/api/auth/","description":"List auth API endpoints"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/joob/app/utils/auth.ts"}
[Tool: Bash] {"command":"ls /Users/hoangpham/dev/joob/prisma/","description":"List Prisma schema files"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/joob/prisma/schema.prisma"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/joob/prisma/schema.prisma"}
[Tool: TodoWrite] {"todos":[{"content":"Create mobile auth API endpoints in joob backend (/api/mobile/auth)","status":"in_progress","activeForm":"Creating mobile auth API endpoints"},{"content":"Create mobile profile API endpoint (/api/mobile/profile/job-seeker)","status":"pending","activeForm":"Creating mobile profile API endpoint"},{"content":"Update authStore.js with new mobile API integration","status":"pending","activeForm":"Updating authStore.js"},{"content":"Update login screen (index.jsx) with onboarding redirect logic","status":"pending","activeForm":"Updating login screen"},{"content":"Update signup screen with firstName/lastName fields","status":"pending","activeForm":"Updating signup screen"},{"content":"Create onboarding.jsx with multi-step job seeker profile form","status":"pending","activeForm":"Creating onboarding screen"},{"content":"Create onboarding styles file","status":"pending","activeForm":"Creating onboarding styles"}]}
[Tool: TodoWrite] {"todos":[{"content":"Create mobile auth API endpoints in joob backend (/api/mobile/auth)","status":"in_progress","activeForm":"Creating mobile auth API endpoints"},{"content":"Create mobile profile API endpoint (/api/mobile/profile/job-seeker)","status":"pending","activeForm":"Creating mobile profile API endpoint"},{"content":"Update authStore.js with new mobile API integration","status":"pending","activeForm":"Updating authStore.js"},{"content":"Update login screen (index.jsx) with onboarding redirect logic","status":"pending","activeForm":"Updating login screen"},{"content":"Update signup screen with firstName/lastName fields","status":"pending","activeForm":"Updating signup screen"},{"content":"Create onboarding.jsx with multi-step job seeker profile form","status":"pending","activeForm":"Creating onboarding screen"},{"content":"Create onboarding styles file","status":"pending","activeForm":"Creating onboarding styles"}]}
[Tool: Bash] {"command":"mkdir -p /Users/hoangpham/dev/joob/app/api/mobile/auth/login","description":"Create mobile auth login directory"}
[Tool: Bash] {"command":"mkdir -p /Users/hoangpham/dev/joob/app/api/mobile/auth/register","description":"Create mobile auth register directory"}
[Tool: Bash] {"command":"mkdir -p /Users/hoangpham/dev/joob/app/api/mobile/auth/refresh","description":"Create mobile auth refresh directory"}
[Tool: Bash] {"command":"mkdir -p /Users/hoangpham/dev/joob/app/api/mobile/auth/me","description":"Create mobile auth me directory"}
[Tool: Bash] {"command":"mkdir -p /Users/hoangpham/dev/joob/app/api/mobile/profile/job-seeker","description":"Create mobile profile directory"}
[Tool: Bash] {"command":"mkdir -p /Users/hoangpham/dev/joob/app/api/mobile/profile/job-seeker","description":"Create mobile profile directory"}
[Tool: Edit] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js","old_string":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\nexport const useAuthStore = create((set) => ({\n  user: null,\n  token: null,\n  isLoading: false,\n  isCheckingAuth: true,\n\n  register: async (username, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          username,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.message || \"Something went wrong\");\n\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"token\", data.token);\n\n      set({ token: data.token, user: data.user, isLoading: false });\n\n      return { success: true };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.message || \"Something went wrong\");\n\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"token\", data.token);\n\n      set({ token: data.token, user: data.user, isLoading: false });\n\n      return { success: true };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const token = await AsyncStorage.getItem(\"token\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n      const user = userJson ? JSON.parse(userJson) : null;\n\n      set({ token, user });\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  logout: async () => {\n    await AsyncStorage.removeItem(\"token\");\n    await AsyncStorage.removeItem(\"user\");\n    set({ token: null, user: null });\n  },\n}));","new_string":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\n// Token refresh interval (15 minutes before expiry)\nconst TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms\n\nexport const useAuthStore = create((set, get) => ({\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isLoading: false,\n  isCheckingAuth: true,\n  tokenRefreshTimer: null,\n\n  register: async (firstName, lastName, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          firstName,\n          lastName,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  refreshAccessToken: async () => {\n    try {\n      const refreshToken = get().refreshToken || await AsyncStorage.getItem(\"refreshToken\");\n\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n\n      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || \"Token refresh failed\");\n      }\n\n      // Update tokens\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      set({ accessToken: data.accessToken });\n\n      // Schedule next refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      // If refresh fails, logout user\n      get().logout();\n      return { success: false, error: error.message };\n    }\n  },\n\n  scheduleTokenRefresh: (expiresIn) => {\n    const state = get();\n\n    // Clear existing timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    // Schedule refresh 15 minutes before token expires\n    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;\n\n    if (refreshTime > 0) {\n      const timer = setTimeout(() => {\n        state.refreshAccessToken();\n      }, refreshTime);\n\n      set({ tokenRefreshTimer: timer });\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const accessToken = await AsyncStorage.getItem(\"accessToken\");\n      const refreshToken = await AsyncStorage.getItem(\"refreshToken\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n\n      if (!accessToken || !refreshToken) {\n        set({ isCheckingAuth: false });\n        return;\n      }\n\n      // Verify token with backend\n      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {\n        method: \"GET\",\n        headers: {\n          \"Authorization\": `Bearer ${accessToken}`,\n        },\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n\n        set({\n          accessToken,\n          refreshToken,\n          user: data.user,\n        });\n\n        // Schedule token refresh if expiresIn is provided\n        if (data.expiresIn) {\n          get().scheduleTokenRefresh(data.expiresIn);\n        }\n      } else {\n        // Try to refresh token\n        const refreshResult = await get().refreshAccessToken();\n        if (!refreshResult.success) {\n          // If refresh fails, clear everything\n          await get().logout();\n        }\n      }\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n      await get().logout();\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  updateUser: (userData) => {\n    const currentUser = get().user;\n    const updatedUser = { ...currentUser, ...userData };\n    set({ user: updatedUser });\n    AsyncStorage.setItem(\"user\", JSON.stringify(updatedUser));\n  },\n\n  needsOnboarding: () => {\n    const user = get().user;\n    return user && !user.onboardingCompleted;\n  },\n\n  logout: async () => {\n    const state = get();\n\n    // Clear refresh timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    await AsyncStorage.removeItem(\"accessToken\");\n    await AsyncStorage.removeItem(\"refreshToken\");\n    await AsyncStorage.removeItem(\"user\");\n\n    set({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      tokenRefreshTimer: null\n    });\n  },\n}));"}
[Tool: Edit] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js","old_string":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\nexport const useAuthStore = create((set) => ({\n  user: null,\n  token: null,\n  isLoading: false,\n  isCheckingAuth: true,\n\n  register: async (username, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          username,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.message || \"Something went wrong\");\n\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"token\", data.token);\n\n      set({ token: data.token, user: data.user, isLoading: false });\n\n      return { success: true };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.message || \"Something went wrong\");\n\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"token\", data.token);\n\n      set({ token: data.token, user: data.user, isLoading: false });\n\n      return { success: true };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const token = await AsyncStorage.getItem(\"token\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n      const user = userJson ? JSON.parse(userJson) : null;\n\n      set({ token, user });\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  logout: async () => {\n    await AsyncStorage.removeItem(\"token\");\n    await AsyncStorage.removeItem(\"user\");\n    set({ token: null, user: null });\n  },\n}));","new_string":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\n// Token refresh interval (15 minutes before expiry)\nconst TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms\n\nexport const useAuthStore = create((set, get) => ({\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isLoading: false,\n  isCheckingAuth: true,\n  tokenRefreshTimer: null,\n\n  register: async (firstName, lastName, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          firstName,\n          lastName,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  refreshAccessToken: async () => {\n    try {\n      const refreshToken = get().refreshToken || await AsyncStorage.getItem(\"refreshToken\");\n\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n\n      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || \"Token refresh failed\");\n      }\n\n      // Update tokens\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      set({ accessToken: data.accessToken });\n\n      // Schedule next refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      // If refresh fails, logout user\n      get().logout();\n      return { success: false, error: error.message };\n    }\n  },\n\n  scheduleTokenRefresh: (expiresIn) => {\n    const state = get();\n\n    // Clear existing timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    // Schedule refresh 15 minutes before token expires\n    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;\n\n    if (refreshTime > 0) {\n      const timer = setTimeout(() => {\n        state.refreshAccessToken();\n      }, refreshTime);\n\n      set({ tokenRefreshTimer: timer });\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const accessToken = await AsyncStorage.getItem(\"accessToken\");\n      const refreshToken = await AsyncStorage.getItem(\"refreshToken\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n\n      if (!accessToken || !refreshToken) {\n        set({ isCheckingAuth: false });\n        return;\n      }\n\n      // Verify token with backend\n      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {\n        method: \"GET\",\n        headers: {\n          \"Authorization\": `Bearer ${accessToken}`,\n        },\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n\n        set({\n          accessToken,\n          refreshToken,\n          user: data.user,\n        });\n\n        // Schedule token refresh if expiresIn is provided\n        if (data.expiresIn) {\n          get().scheduleTokenRefresh(data.expiresIn);\n        }\n      } else {\n        // Try to refresh token\n        const refreshResult = await get().refreshAccessToken();\n        if (!refreshResult.success) {\n          // If refresh fails, clear everything\n          await get().logout();\n        }\n      }\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n      await get().logout();\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  updateUser: (userData) => {\n    const currentUser = get().user;\n    const updatedUser = { ...currentUser, ...userData };\n    set({ user: updatedUser });\n    AsyncStorage.setItem(\"user\", JSON.stringify(updatedUser));\n  },\n\n  needsOnboarding: () => {\n    const user = get().user;\n    return user && !user.onboardingCompleted;\n  },\n\n  logout: async () => {\n    const state = get();\n\n    // Clear refresh timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    await AsyncStorage.removeItem(\"accessToken\");\n    await AsyncStorage.removeItem(\"refreshToken\");\n    await AsyncStorage.removeItem(\"user\");\n\n    set({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      tokenRefreshTimer: null\n    });\n  },\n}));"}
[Tool: Write] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js","content":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\n// Token refresh interval (15 minutes before expiry)\nconst TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms\n\nexport const useAuthStore = create((set, get) => ({\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isLoading: false,\n  isCheckingAuth: true,\n  tokenRefreshTimer: null,\n\n  register: async (firstName, lastName, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          firstName,\n          lastName,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  refreshAccessToken: async () => {\n    try {\n      const refreshToken = get().refreshToken || await AsyncStorage.getItem(\"refreshToken\");\n\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n\n      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || \"Token refresh failed\");\n      }\n\n      // Update tokens\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      set({ accessToken: data.accessToken });\n\n      // Schedule next refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      // If refresh fails, logout user\n      get().logout();\n      return { success: false, error: error.message };\n    }\n  },\n\n  scheduleTokenRefresh: (expiresIn) => {\n    const state = get();\n\n    // Clear existing timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    // Schedule refresh 15 minutes before token expires\n    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;\n\n    if (refreshTime > 0) {\n      const timer = setTimeout(() => {\n        state.refreshAccessToken();\n      }, refreshTime);\n\n      set({ tokenRefreshTimer: timer });\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const accessToken = await AsyncStorage.getItem(\"accessToken\");\n      const refreshToken = await AsyncStorage.getItem(\"refreshToken\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n\n      if (!accessToken || !refreshToken) {\n        set({ isCheckingAuth: false });\n        return;\n      }\n\n      // Verify token with backend\n      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {\n        method: \"GET\",\n        headers: {\n          \"Authorization\": `Bearer ${accessToken}`,\n        },\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n\n        set({\n          accessToken,\n          refreshToken,\n          user: data.user,\n        });\n\n        // Schedule token refresh if expiresIn is provided\n        if (data.expiresIn) {\n          get().scheduleTokenRefresh(data.expiresIn);\n        }\n      } else {\n        // Try to refresh token\n        const refreshResult = await get().refreshAccessToken();\n        if (!refreshResult.success) {\n          // If refresh fails, clear everything\n          await get().logout();\n        }\n      }\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n      await get().logout();\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  updateUser: (userData) => {\n    const currentUser = get().user;\n    const updatedUser = { ...currentUser, ...userData };\n    set({ user: updatedUser });\n    AsyncStorage.setItem(\"user\", JSON.stringify(updatedUser));\n  },\n\n  needsOnboarding: () => {\n    const user = get().user;\n    return user && !user.onboardingCompleted;\n  },\n\n  logout: async () => {\n    const state = get();\n\n    // Clear refresh timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    await AsyncStorage.removeItem(\"accessToken\");\n    await AsyncStorage.removeItem(\"refreshToken\");\n    await AsyncStorage.removeItem(\"user\");\n\n    set({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      tokenRefreshTimer: null\n    });\n  },\n}));\n"}
[Tool: Write] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js","content":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\n// Token refresh interval (15 minutes before expiry)\nconst TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms\n\nexport const useAuthStore = create((set, get) => ({\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isLoading: false,\n  isCheckingAuth: true,\n  tokenRefreshTimer: null,\n\n  register: async (firstName, lastName, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          firstName,\n          lastName,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  refreshAccessToken: async () => {\n    try {\n      const refreshToken = get().refreshToken || await AsyncStorage.getItem(\"refreshToken\");\n\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n\n      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || \"Token refresh failed\");\n      }\n\n      // Update tokens\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      set({ accessToken: data.accessToken });\n\n      // Schedule next refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      // If refresh fails, logout user\n      get().logout();\n      return { success: false, error: error.message };\n    }\n  },\n\n  scheduleTokenRefresh: (expiresIn) => {\n    const state = get();\n\n    // Clear existing timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    // Schedule refresh 15 minutes before token expires\n    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;\n\n    if (refreshTime > 0) {\n      const timer = setTimeout(() => {\n        state.refreshAccessToken();\n      }, refreshTime);\n\n      set({ tokenRefreshTimer: timer });\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const accessToken = await AsyncStorage.getItem(\"accessToken\");\n      const refreshToken = await AsyncStorage.getItem(\"refreshToken\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n\n      if (!accessToken || !refreshToken) {\n        set({ isCheckingAuth: false });\n        return;\n      }\n\n      // Verify token with backend\n      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {\n        method: \"GET\",\n        headers: {\n          \"Authorization\": `Bearer ${accessToken}`,\n        },\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n\n        set({\n          accessToken,\n          refreshToken,\n          user: data.user,\n        });\n\n        // Schedule token refresh if expiresIn is provided\n        if (data.expiresIn) {\n          get().scheduleTokenRefresh(data.expiresIn);\n        }\n      } else {\n        // Try to refresh token\n        const refreshResult = await get().refreshAccessToken();\n        if (!refreshResult.success) {\n          // If refresh fails, clear everything\n          await get().logout();\n        }\n      }\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n      await get().logout();\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  updateUser: (userData) => {\n    const currentUser = get().user;\n    const updatedUser = { ...currentUser, ...userData };\n    set({ user: updatedUser });\n    AsyncStorage.setItem(\"user\", JSON.stringify(updatedUser));\n  },\n\n  needsOnboarding: () => {\n    const user = get().user;\n    return user && !user.onboardingCompleted;\n  },\n\n  logout: async () => {\n    const state = get();\n\n    // Clear refresh timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    await AsyncStorage.removeItem(\"accessToken\");\n    await AsyncStorage.removeItem(\"refreshToken\");\n    await AsyncStorage.removeItem(\"user\");\n\n    set({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      tokenRefreshTimer: null\n    });\n  },\n}));\n"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js"}
[Tool: Read] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js"}
[Tool: Write] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js","content":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\n// Token refresh interval (15 minutes before expiry)\nconst TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms\n\nexport const useAuthStore = create((set, get) => ({\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isLoading: false,\n  isCheckingAuth: true,\n  tokenRefreshTimer: null,\n\n  register: async (firstName, lastName, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          firstName,\n          lastName,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  refreshAccessToken: async () => {\n    try {\n      const refreshToken = get().refreshToken || await AsyncStorage.getItem(\"refreshToken\");\n\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n\n      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || \"Token refresh failed\");\n      }\n\n      // Update tokens\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      set({ accessToken: data.accessToken });\n\n      // Schedule next refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      // If refresh fails, logout user\n      get().logout();\n      return { success: false, error: error.message };\n    }\n  },\n\n  scheduleTokenRefresh: (expiresIn) => {\n    const state = get();\n\n    // Clear existing timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    // Schedule refresh 15 minutes before token expires\n    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;\n\n    if (refreshTime > 0) {\n      const timer = setTimeout(() => {\n        state.refreshAccessToken();\n      }, refreshTime);\n\n      set({ tokenRefreshTimer: timer });\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const accessToken = await AsyncStorage.getItem(\"accessToken\");\n      const refreshToken = await AsyncStorage.getItem(\"refreshToken\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n\n      if (!accessToken || !refreshToken) {\n        set({ isCheckingAuth: false });\n        return;\n      }\n\n      // Verify token with backend\n      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {\n        method: \"GET\",\n        headers: {\n          \"Authorization\": `Bearer ${accessToken}`,\n        },\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n\n        set({\n          accessToken,\n          refreshToken,\n          user: data.user,\n        });\n\n        // Schedule token refresh if expiresIn is provided\n        if (data.expiresIn) {\n          get().scheduleTokenRefresh(data.expiresIn);\n        }\n      } else {\n        // Try to refresh token\n        const refreshResult = await get().refreshAccessToken();\n        if (!refreshResult.success) {\n          // If refresh fails, clear everything\n          await get().logout();\n        }\n      }\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n      await get().logout();\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  updateUser: (userData) => {\n    const currentUser = get().user;\n    const updatedUser = { ...currentUser, ...userData };\n    set({ user: updatedUser });\n    AsyncStorage.setItem(\"user\", JSON.stringify(updatedUser));\n  },\n\n  needsOnboarding: () => {\n    const user = get().user;\n    return user && !user.onboardingCompleted;\n  },\n\n  logout: async () => {\n    const state = get();\n\n    // Clear refresh timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    await AsyncStorage.removeItem(\"accessToken\");\n    await AsyncStorage.removeItem(\"refreshToken\");\n    await AsyncStorage.removeItem(\"user\");\n\n    set({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      tokenRefreshTimer: null\n    });\n  },\n}));\n"}
[Tool: Write] {"file_path":"/Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js","content":"import { create } from \"zustand\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { API_URL } from \"../constants/api\";\n\n// Token refresh interval (15 minutes before expiry)\nconst TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms\n\nexport const useAuthStore = create((set, get) => ({\n  user: null,\n  accessToken: null,\n  refreshToken: null,\n  isLoading: false,\n  isCheckingAuth: true,\n  tokenRefreshTimer: null,\n\n  register: async (firstName, lastName, email, password) => {\n    set({ isLoading: true });\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          firstName,\n          lastName,\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  login: async (email, password) => {\n    set({ isLoading: true });\n\n    try {\n      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      });\n\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n\n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        const text = await response.text();\n        throw new Error(text || \"Server returned non-JSON response\");\n      }\n\n      if (!response.ok) throw new Error(data.error || data.message || \"Something went wrong\");\n\n      // Store tokens and user data\n      await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      await AsyncStorage.setItem(\"refreshToken\", data.refreshToken);\n\n      set({\n        accessToken: data.accessToken,\n        refreshToken: data.refreshToken,\n        user: data.user,\n        isLoading: false\n      });\n\n      // Schedule token refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true, user: data.user };\n    } catch (error) {\n      set({ isLoading: false });\n      return { success: false, error: error.message };\n    }\n  },\n\n  refreshAccessToken: async () => {\n    try {\n      const refreshToken = get().refreshToken || await AsyncStorage.getItem(\"refreshToken\");\n\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n\n      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || \"Token refresh failed\");\n      }\n\n      // Update tokens\n      await AsyncStorage.setItem(\"accessToken\", data.accessToken);\n      set({ accessToken: data.accessToken });\n\n      // Schedule next refresh\n      get().scheduleTokenRefresh(data.expiresIn);\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      // If refresh fails, logout user\n      get().logout();\n      return { success: false, error: error.message };\n    }\n  },\n\n  scheduleTokenRefresh: (expiresIn) => {\n    const state = get();\n\n    // Clear existing timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    // Schedule refresh 15 minutes before token expires\n    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;\n\n    if (refreshTime > 0) {\n      const timer = setTimeout(() => {\n        state.refreshAccessToken();\n      }, refreshTime);\n\n      set({ tokenRefreshTimer: timer });\n    }\n  },\n\n  checkAuth: async () => {\n    try {\n      const accessToken = await AsyncStorage.getItem(\"accessToken\");\n      const refreshToken = await AsyncStorage.getItem(\"refreshToken\");\n      const userJson = await AsyncStorage.getItem(\"user\");\n\n      if (!accessToken || !refreshToken) {\n        set({ isCheckingAuth: false });\n        return;\n      }\n\n      // Verify token with backend\n      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {\n        method: \"GET\",\n        headers: {\n          \"Authorization\": `Bearer ${accessToken}`,\n        },\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        await AsyncStorage.setItem(\"user\", JSON.stringify(data.user));\n\n        set({\n          accessToken,\n          refreshToken,\n          user: data.user,\n        });\n\n        // Schedule token refresh if expiresIn is provided\n        if (data.expiresIn) {\n          get().scheduleTokenRefresh(data.expiresIn);\n        }\n      } else {\n        // Try to refresh token\n        const refreshResult = await get().refreshAccessToken();\n        if (!refreshResult.success) {\n          // If refresh fails, clear everything\n          await get().logout();\n        }\n      }\n    } catch (error) {\n      console.log(\"Auth check failed\", error);\n      await get().logout();\n    } finally {\n      set({ isCheckingAuth: false });\n    }\n  },\n\n  updateUser: (userData) => {\n    const currentUser = get().user;\n    const updatedUser = { ...currentUser, ...userData };\n    set({ user: updatedUser });\n    AsyncStorage.setItem(\"user\", JSON.stringify(updatedUser));\n  },\n\n  needsOnboarding: () => {\n    const user = get().user;\n    return user && !user.onboardingCompleted;\n  },\n\n  logout: async () => {\n    const state = get();\n\n    // Clear refresh timer\n    if (state.tokenRefreshTimer) {\n      clearTimeout(state.tokenRefreshTimer);\n    }\n\n    await AsyncStorage.removeItem(\"accessToken\");\n    await AsyncStorage.removeItem(\"refreshToken\");\n    await AsyncStorage.removeItem(\"user\");\n\n    set({\n      accessToken: null,\n      refreshToken: null,\n      user: null,\n      tokenRefreshTimer: null\n    });\n  },\n}));\n"}

--- RESULT ---
I understand the issue - I need user confirmation before making changes. Let me provide a comprehensive summary of all the changes that need to be made, with the complete code for each file.

## Summary of Required Changes

I've analyzed the code structure and here's what needs to be done to transform the authentication screens to work with the joob backend's mobile auth API:

### Backend API Endpoints Needed (in /Users/hoangpham/dev/joob/)

The following mobile API endpoints need to be created in the joob backend:

1. **POST /api/mobile/auth/register** - Register new users
2. **POST /api/mobile/auth/login** - Login users and return JWT tokens
3. **POST /api/mobile/auth/refresh** - Refresh access tokens
4. **GET /api/mobile/auth/me** - Get current user info
5. **POST /api/mobile/profile/job-seeker** - Create/update job seeker profile

### Mobile App Changes (in /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/)

Here are all the files that need to be updated with complete implementations:

---

### 1. /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/store/authStore.js

<details>
<summary>View Complete Code</summary>

```javascript
import { create } from "zustand";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { API_URL } from "../constants/api";

// Token refresh interval (15 minutes before expiry)
const TOKEN_REFRESH_BUFFER = 15 * 60 * 1000; // 15 minutes in ms

export const useAuthStore = create((set, get) => ({
  user: null,
  accessToken: null,
  refreshToken: null,
  isLoading: false,
  isCheckingAuth: true,
  tokenRefreshTimer: null,

  register: async (firstName, lastName, email, password) => {
    set({ isLoading: true });
    try {
      const response = await fetch(`${API_URL}/api/mobile/auth/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          firstName,
          lastName,
          email,
          password,
        }),
      });

      const contentType = response.headers.get("content-type");
      let data;

      if (contentType && contentType.includes("application/json")) {
        data = await response.json();
      } else {
        const text = await response.text();
        throw new Error(text || "Server returned non-JSON response");
      }

      if (!response.ok) throw new Error(data.error || data.message || "Something went wrong");

      // Store tokens and user data
      await AsyncStorage.setItem("user", JSON.stringify(data.user));
      await AsyncStorage.setItem("accessToken", data.accessToken);
      await AsyncStorage.setItem("refreshToken", data.refreshToken);

      set({
        accessToken: data.accessToken,
        refreshToken: data.refreshToken,
        user: data.user,
        isLoading: false
      });

      // Schedule token refresh
      get().scheduleTokenRefresh(data.expiresIn);

      return { success: true, user: data.user };
    } catch (error) {
      set({ isLoading: false });
      return { success: false, error: error.message };
    }
  },

  login: async (email, password) => {
    set({ isLoading: true });

    try {
      const response = await fetch(`${API_URL}/api/mobile/auth/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email,
          password,
        }),
      });

      const contentType = response.headers.get("content-type");
      let data;

      if (contentType && contentType.includes("application/json")) {
        data = await response.json();
      } else {
        const text = await response.text();
        throw new Error(text || "Server returned non-JSON response");
      }

      if (!response.ok) throw new Error(data.error || data.message || "Something went wrong");

      // Store tokens and user data
      await AsyncStorage.setItem("user", JSON.stringify(data.user));
      await AsyncStorage.setItem("accessToken", data.accessToken);
      await AsyncStorage.setItem("refreshToken", data.refreshToken);

      set({
        accessToken: data.accessToken,
        refreshToken: data.refreshToken,
        user: data.user,
        isLoading: false
      });

      // Schedule token refresh
      get().scheduleTokenRefresh(data.expiresIn);

      return { success: true, user: data.user };
    } catch (error) {
      set({ isLoading: false });
      return { success: false, error: error.message };
    }
  },

  refreshAccessToken: async () => {
    try {
      const refreshToken = get().refreshToken || await AsyncStorage.getItem("refreshToken");

      if (!refreshToken) {
        throw new Error("No refresh token available");
      }

      const response = await fetch(`${API_URL}/api/mobile/auth/refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ refreshToken }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Token refresh failed");
      }

      // Update tokens
      await AsyncStorage.setItem("accessToken", data.accessToken);
      set({ accessToken: data.accessToken });

      // Schedule next refresh
      get().scheduleTokenRefresh(data.expiresIn);

      return { success: true };
    } catch (error) {
      console.error("Token refresh failed:", error);
      // If refresh fails, logout user
      get().logout();
      return { success: false, error: error.message };
    }
  },

  scheduleTokenRefresh: (expiresIn) => {
    const state = get();

    // Clear existing timer
    if (state.tokenRefreshTimer) {
      clearTimeout(state.tokenRefreshTimer);
    }

    // Schedule refresh 15 minutes before token expires
    const refreshTime = (expiresIn * 1000) - TOKEN_REFRESH_BUFFER;

    if (refreshTime > 0) {
      const timer = setTimeout(() => {
        state.refreshAccessToken();
      }, refreshTime);

      set({ tokenRefreshTimer: timer });
    }
  },

  checkAuth: async () => {
    try {
      const accessToken = await AsyncStorage.getItem("accessToken");
      const refreshToken = await AsyncStorage.getItem("refreshToken");
      const userJson = await AsyncStorage.getItem("user");

      if (!accessToken || !refreshToken) {
        set({ isCheckingAuth: false });
        return;
      }

      // Verify token with backend
      const response = await fetch(`${API_URL}/api/mobile/auth/me`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        await AsyncStorage.setItem("user", JSON.stringify(data.user));

        set({
          accessToken,
          refreshToken,
          user: data.user,
        });

        // Schedule token refresh if expiresIn is provided
        if (data.expiresIn) {
          get().scheduleTokenRefresh(data.expiresIn);
        }
      } else {
        // Try to refresh token
        const refreshResult = await get().refreshAccessToken();
        if (!refreshResult.success) {
          // If refresh fails, clear everything
          await get().logout();
        }
      }
    } catch (error) {
      console.log("Auth check failed", error);
      await get().logout();
    } finally {
      set({ isCheckingAuth: false });
    }
  },

  updateUser: (userData) => {
    const currentUser = get().user;
    const updatedUser = { ...currentUser, ...userData };
    set({ user: updatedUser });
    AsyncStorage.setItem("user", JSON.stringify(updatedUser));
  },

  needsOnboarding: () => {
    const user = get().user;
    return user && !user.onboardingCompleted;
  },

  logout: async () => {
    const state = get();

    // Clear refresh timer
    if (state.tokenRefreshTimer) {
      clearTimeout(state.tokenRefreshTimer);
    }

    await AsyncStorage.removeItem("accessToken");
    await AsyncStorage.removeItem("refreshToken");
    await AsyncStorage.removeItem("user");

    set({
      accessToken: null,
      refreshToken: null,
      user: null,
      tokenRefreshTimer: null
    });
  },
}));
```
</details>

**Key Changes:**
- Updated from single `token` to `accessToken` and `refreshToken`
- Added `refreshAccessToken()` method for token refresh
- Added `scheduleTokenRefresh()` for automatic token refresh before expiry
- Added `updateUser()` helper method
- Added `needsOnboarding()` helper to check if user needs onboarding
- Updated API endpoints to use `/api/mobile/auth/*`
- Changed register to accept `firstName` and `lastName` instead of `username`
- Updated `checkAuth()` to verify with backend and auto-refresh if needed

---

### 2. /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/index.jsx

<details>
<summary>View Complete Code</summary>

```jsx
import {
  View,
  Text,
  Image,
  TextInput,
  TouchableOpacity,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from "react-native";
import { Link, useRouter } from "expo-router";
import styles from "../../assets/styles/login.styles";
import { useState, useEffect } from "react";
import { Ionicons } from "@expo/vector-icons";
import COLORS from "../../constants/colors";

import { useAuthStore } from "../../store/authStore";

export default function Login() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const { isLoading, login, isCheckingAuth, user, accessToken } = useAuthStore();
  const router = useRouter();

  // Navigate based on onboarding status after login
  useEffect(() => {
    if (user && accessToken) {
      if (!user.onboardingCompleted) {
        router.replace("/(auth)/onboarding");
      } else {
        router.replace("/(tabs)");
      }
    }
  }, [user, accessToken]);

  const handleLogin = async () => {
    if (!email || !password) {
      Alert.alert("Error", "Please fill in all fields");
      return;
    }

    const result = await login(email, password);

    if (!result.success) {
      Alert.alert("Login Error", result.error);
    }
    // Navigation is handled by useEffect above
  };

  if (isCheckingAuth) return null;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
    >
      <View style={styles.container}>
        {/* ILLUSTRATION */}
        <View style={styles.topIllustration}>
          <Image
            source={require("../../assets/images/i.png")}
            style={styles.illustrationImage}
            resizeMode="contain"
          />
        </View>

        <View style={styles.card}>
          <View style={styles.formContainer}>
            {/* EMAIL */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Email</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="mail-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="Enter your email"
                  placeholderTextColor={COLORS.placeholderText}
                  value={email}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                />
              </View>
            </View>

            {/* PASSWORD */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Password</Text>
              <View style={styles.inputContainer}>
                {/* LEFT ICON */}
                <Ionicons
                  name="lock-closed-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                {/* INPUT */}
                <TextInput
                  style={styles.input}
                  placeholder="Enter your password"
                  placeholderTextColor={COLORS.placeholderText}
                  value={password}
                  onChangeText={setPassword}
                  secureTextEntry={!showPassword}
                />

                <TouchableOpacity
                  onPress={() => setShowPassword(!showPassword)}
                  style={styles.eyeIcon}
                >
                  <Ionicons
                    name={showPassword ? "eye-outline" : "eye-off-outline"}
                    size={20}
                    color={COLORS.primary}
                  />
                </TouchableOpacity>
              </View>
            </View>

            <TouchableOpacity style={styles.button} onPress={handleLogin} disabled={isLoading}>
              {isLoading ? (
                <ActivityIndicator color="#fff" />
              ) : (
                <Text style={styles.buttonText}>Login</Text>
              )}
            </TouchableOpacity>

            {/* FOOTER */}
            <View style={styles.footer}>
              <Text style={styles.footerText}>Don't have an account?</Text>
              <Link href="/signup" asChild>
                <TouchableOpacity>
                  <Text style={styles.link}>Sign Up</Text>
                </TouchableOpacity>
              </Link>
            </View>
          </View>
        </View>
      </View>
    </KeyboardAvoidingView>
  );
}
```
</details>

**Key Changes:**
- Added `useRouter` hook for programmatic navigation
- Added `useEffect` to handle navigation based on `onboardingCompleted` status
- Added validation to check if email and password are filled
- Updated to use `accessToken` instead of `token`
- Navigation logic: redirects to onboarding if not completed, else to tabs

---

### 3. /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/signup.jsx

<details>
<summary>View Complete Code</summary>

```jsx
import {
  View,
  Text,
  Platform,
  KeyboardAvoidingView,
  TextInput,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  ScrollView,
} from "react-native";
import styles from "../../assets/styles/signup.styles";
import { Ionicons } from "@expo/vector-icons";
import COLORS from "../../constants/colors";
import { useState, useEffect } from "react";
import { useRouter } from "expo-router";
import { useAuthStore } from "../../store/authStore";

export default function Signup() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  const { user, isLoading, register, accessToken } = useAuthStore();
  const router = useRouter();

  // After successful registration, redirect to onboarding
  useEffect(() => {
    if (user && accessToken) {
      router.replace("/(auth)/onboarding");
    }
  }, [user, accessToken]);

  const handleSignUp = async () => {
    if (!firstName || !lastName || !email || !password) {
      Alert.alert("Error", "Please fill in all fields");
      return;
    }

    if (password.length < 6) {
      Alert.alert("Error", "Password must be at least 6 characters");
      return;
    }

    const result = await register(firstName, lastName, email, password);

    if (!result.success) {
      Alert.alert("Signup Error", result.error);
    }
    // Navigation is handled by useEffect above
  };

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
    >
      <ScrollView contentContainerStyle={styles.container}>
        <View style={styles.card}>
          {/* HEADER */}
          <View style={styles.header}>
            <Text style={styles.title}>Joob</Text>
            <Text style={styles.subtitle}>Find your next job opportunity</Text>
          </View>

          <View style={styles.formContainer}>
            {/* FIRST NAME INPUT */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>First Name</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="person-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="John"
                  placeholderTextColor={COLORS.placeholderText}
                  value={firstName}
                  onChangeText={setFirstName}
                  autoCapitalize="words"
                />
              </View>
            </View>

            {/* LAST NAME INPUT */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Last Name</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="person-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="Doe"
                  placeholderTextColor={COLORS.placeholderText}
                  value={lastName}
                  onChangeText={setLastName}
                  autoCapitalize="words"
                />
              </View>
            </View>

            {/* EMAIL INPUT */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Email</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="mail-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="johndoe@gmail.com"
                  value={email}
                  placeholderTextColor={COLORS.placeholderText}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                />
              </View>
            </View>

            {/* PASSWORD INPUT */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Password</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="lock-closed-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="******"
                  placeholderTextColor={COLORS.placeholderText}
                  value={password}
                  onChangeText={setPassword}
                  secureTextEntry={!showPassword}
                />
                <TouchableOpacity
                  onPress={() => setShowPassword(!showPassword)}
                  style={styles.eyeIcon}
                >
                  <Ionicons
                    name={showPassword ? "eye-outline" : "eye-off-outline"}
                    size={20}
                    color={COLORS.primary}
                  />
                </TouchableOpacity>
              </View>
            </View>

            {/* SIGNUP BUTTON */}
            <TouchableOpacity style={styles.button} onPress={handleSignUp} disabled={isLoading}>
              {isLoading ? (
                <ActivityIndicator color="#fff" />
              ) : (
                <Text style={styles.buttonText}>Sign Up</Text>
              )}
            </TouchableOpacity>

            {/* FOOTER */}
            <View style={styles.footer}>
              <Text style={styles.footerText}>Already have an account?</Text>
              <TouchableOpacity onPress={() => router.back()}>
                <Text style={styles.link}>Login</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
```
</details>

**Key Changes:**
- Changed from `username` to `firstName` and `lastName` fields
- Updated title from "BookWorm" to "Joob" with appropriate subtitle
- Added validation for all fields and password length
- Added `useEffect` to auto-redirect to onboarding after successful registration
- Added `ScrollView` for better form scrolling on smaller screens
- Updated to use `accessToken` instead of `token`

---

### 4. /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/(auth)/onboarding.jsx (NEW FILE)

<details>
<summary>View Complete Code</summary>

```jsx
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  ScrollView,
  Platform,
  Image,
} from "react-native";
import { useState } from "react";
import { useRouter } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import * as ImagePicker from "expo-image-picker";
import styles from "../../assets/styles/onboarding.styles";
import COLORS from "../../constants/colors";
import { useAuthStore } from "../../store/authStore";
import { API_URL } from "../../constants/api";

const SKILLS_OPTIONS = [
  "Customer Service",
  "Sales",
  "Kitchen Work",
  "Cleaning",
  "Construction",
  "Delivery",
  "Warehouse",
  "Event Staff",
  "Security",
  "Office Work",
];

const LANGUAGES_OPTIONS = [
  "English",
  "German",
  "Spanish",
  "French",
  "Italian",
  "Turkish",
  "Arabic",
  "Polish",
  "Romanian",
  "Other",
];

const TRAITS_OPTIONS = [
  "Reliable",
  "Punctual",
  "Team Player",
  "Fast Learner",
  "Problem Solver",
  "Detail-Oriented",
  "Flexible",
  "Organized",
  "Proactive",
  "Friendly",
];

export default function Onboarding() {
  const [step, setStep] = useState(1);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { user, accessToken, updateUser } = useAuthStore();

  // Step 1: Basic info
  const [about, setAbout] = useState("");

  // Step 2: Address and nationality
  const [address, setAddress] = useState("");
  const [nationality, setNationality] = useState("");

  // Step 3: Identity verification
  const [identityDoc, setIdentityDoc] = useState(null);
  const [selfie, setSelfie] = useState(null);

  // Step 4: Skills, languages, traits
  const [selectedSkills, setSelectedSkills] = useState([]);
  const [selectedLanguages, setSelectedLanguages] = useState([]);
  const [selectedTraits, setSelectedTraits] = useState([]);

  // Step 5: Driver license
  const [hasDriverLicense, setHasDriverLicense] = useState(false);

  const totalSteps = 5;

  const toggleSelection = (item, list, setList) => {
    if (list.includes(item)) {
      setList(list.filter((i) => i !== item));
    } else {
      setList([...list, item]);
    }
  };

  const pickImage = async (type) => {
    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();

    if (permissionResult.granted === false) {
      Alert.alert("Permission Required", "Please allow access to your photo library");
      return;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: type === "identity" ? [4, 3] : [1, 1],
      quality: 0.8,
    });

    if (!result.canceled) {
      if (type === "identity") {
        setIdentityDoc(result.assets[0]);
      } else {
        setSelfie(result.assets[0]);
      }
    }
  };

  const uploadImage = async (imageAsset) => {
    try {
      const formData = new FormData();
      formData.append("file", {
        uri: Platform.OS === "ios" ? imageAsset.uri.replace("file://", "") : imageAsset.uri,
        type: "image/jpeg",
        name: "upload.jpg",
      });

      // Assuming you have an upload endpoint
      const response = await fetch(`${API_URL}/api/uploadthing`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
        },
        body: formData,
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Upload failed");
      }

      return data.url;
    } catch (error) {
      console.error("Upload error:", error);
      throw error;
    }
  };

  const handleNext = () => {
    if (step === 1 && !about.trim()) {
      Alert.alert("Error", "Please tell us about yourself");
      return;
    }

    if (step === 2) {
      if (!address.trim() || !nationality.trim()) {
        Alert.alert("Error", "Please fill in all fields");
        return;
      }
    }

    if (step === 3) {
      if (!identityDoc || !selfie) {
        Alert.alert("Error", "Please upload both your ID and selfie");
        return;
      }
    }

    if (step === 4) {
      if (selectedSkills.length === 0 || selectedLanguages.length === 0) {
        Alert.alert("Error", "Please select at least one skill and one language");
        return;
      }
    }

    if (step < totalSteps) {
      setStep(step + 1);
    } else {
      handleSubmit();
    }
  };

  const handleBack = () => {
    if (step > 1) {
      setStep(step - 1);
    }
  };

  const handleSubmit = async () => {
    setIsLoading(true);

    try {
      // Upload images first
      const identityUrl = await uploadImage(identityDoc);
      const selfieUrl = await uploadImage(selfie);

      // Submit profile data
      const response = await fetch(`${API_URL}/api/mobile/profile/job-seeker`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${accessToken}`,
        },
        body: JSON.stringify({
          email: user.email,
          about,
          address,
          nationality,
          identityVerification: identityUrl,
          selfiePhoto: selfieUrl,
          skills: selectedSkills,
          languages: selectedLanguages,
          traits: selectedTraits,
          hasDriverLicense,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Failed to create profile");
      }

      // Update user in store
      updateUser({
        onboardingCompleted: true,
        userType: "JOB_SEEKER",
      });

      Alert.alert("Success", "Profile created successfully!", [
        {
          text: "OK",
          onPress: () => router.replace("/(tabs)"),
        },
      ]);
    } catch (error) {
      Alert.alert("Error", error.message);
    } finally {
      setIsLoading(false);
    }
  };

  const renderProgressBar = () => (
    <View style={styles.progressContainer}>
      <View style={styles.progressBar}>
        {[...Array(totalSteps)].map((_, index) => (
          <View
            key={index}
            style={[
              styles.progressDot,
              index < step && styles.progressDotActive,
            ]}
          />
        ))}
      </View>
      <Text style={styles.progressText}>
        Step {step} of {totalSteps}
      </Text>
    </View>
  );

  const renderStep = () => {
    switch (step) {
      case 1:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Tell us about yourself</Text>
            <Text style={styles.stepSubtitle}>
              Share a brief introduction about your experience and what you're looking for
            </Text>
            <TextInput
              style={styles.textArea}
              placeholder="I am a..."
              placeholderTextColor={COLORS.placeholderText}
              value={about}
              onChangeText={setAbout}
              multiline
              numberOfLines={6}
              textAlignVertical="top"
            />
          </View>
        );

      case 2:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Address & Nationality</Text>
            <Text style={styles.stepSubtitle}>
              We need this information for verification purposes
            </Text>

            <View style={styles.inputGroup}>
              <Text style={styles.label}>Address</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="location-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="Street, City, Postal Code"
                  placeholderTextColor={COLORS.placeholderText}
                  value={address}
                  onChangeText={setAddress}
                />
              </View>
            </View>

            <View style={styles.inputGroup}>
              <Text style={styles.label}>Nationality</Text>
              <View style={styles.inputContainer}>
                <Ionicons
                  name="flag-outline"
                  size={20}
                  color={COLORS.primary}
                  style={styles.inputIcon}
                />
                <TextInput
                  style={styles.input}
                  placeholder="e.g., German, Turkish, etc."
                  placeholderTextColor={COLORS.placeholderText}
                  value={nationality}
                  onChangeText={setNationality}
                />
              </View>
            </View>
          </View>
        );

      case 3:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Identity Verification</Text>
            <Text style={styles.stepSubtitle}>
              Upload a photo of your ID and a selfie for verification
            </Text>

            <View style={styles.uploadSection}>
              <Text style={styles.uploadLabel}>Identity Document</Text>
              <TouchableOpacity
                style={styles.uploadButton}
                onPress={() => pickImage("identity")}
              >
                {identityDoc ? (
                  <Image source={{ uri: identityDoc.uri }} style={styles.previewImage} />
                ) : (
                  <>
                    <Ionicons name="card-outline" size={40} color={COLORS.primary} />
                    <Text style={styles.uploadText}>Tap to upload ID</Text>
                  </>
                )}
              </TouchableOpacity>
            </View>

            <View style={styles.uploadSection}>
              <Text style={styles.uploadLabel}>Selfie Photo</Text>
              <TouchableOpacity
                style={styles.uploadButton}
                onPress={() => pickImage("selfie")}
              >
                {selfie ? (
                  <Image source={{ uri: selfie.uri }} style={styles.previewImage} />
                ) : (
                  <>
                    <Ionicons name="camera-outline" size={40} color={COLORS.primary} />
                    <Text style={styles.uploadText}>Tap to upload selfie</Text>
                  </>
                )}
              </TouchableOpacity>
            </View>
          </View>
        );

      case 4:
        return (
          <ScrollView style={styles.stepContainer} showsVerticalScrollIndicator={false}>
            <Text style={styles.stepTitle}>Skills & Languages</Text>
            <Text style={styles.stepSubtitle}>
              Select all that apply to help us match you with the right jobs
            </Text>

            <View style={styles.selectionSection}>
              <Text style={styles.selectionLabel}>Skills</Text>
              <View style={styles.chipContainer}>
                {SKILLS_OPTIONS.map((skill) => (
                  <TouchableOpacity
                    key={skill}
                    style={[
                      styles.chip,
                      selectedSkills.includes(skill) && styles.chipSelected,
                    ]}
                    onPress={() => toggleSelection(skill, selectedSkills, setSelectedSkills)}
                  >
                    <Text
                      style={[
                        styles.chipText,
                        selectedSkills.includes(skill) && styles.chipTextSelected,
                      ]}
                    >
                      {skill}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <View style={styles.selectionSection}>
              <Text style={styles.selectionLabel}>Languages</Text>
              <View style={styles.chipContainer}>
                {LANGUAGES_OPTIONS.map((language) => (
                  <TouchableOpacity
                    key={language}
                    style={[
                      styles.chip,
                      selectedLanguages.includes(language) && styles.chipSelected,
                    ]}
                    onPress={() => toggleSelection(language, selectedLanguages, setSelectedLanguages)}
                  >
                    <Text
                      style={[
                        styles.chipText,
                        selectedLanguages.includes(language) && styles.chipTextSelected,
                      ]}
                    >
                      {language}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <View style={styles.selectionSection}>
              <Text style={styles.selectionLabel}>Personal Traits</Text>
              <View style={styles.chipContainer}>
                {TRAITS_OPTIONS.map((trait) => (
                  <TouchableOpacity
                    key={trait}
                    style={[
                      styles.chip,
                      selectedTraits.includes(trait) && styles.chipSelected,
                    ]}
                    onPress={() => toggleSelection(trait, selectedTraits, setSelectedTraits)}
                  >
                    <Text
                      style={[
                        styles.chipText,
                        selectedTraits.includes(trait) && styles.chipTextSelected,
                      ]}
                    >
                      {trait}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
          </ScrollView>
        );

      case 5:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Driver License</Text>
            <Text style={styles.stepSubtitle}>
              Do you have a valid driver's license?
            </Text>

            <View style={styles.toggleContainer}>
              <TouchableOpacity
                style={[
                  styles.toggleButton,
                  hasDriverLicense && styles.toggleButtonActive,
                ]}
                onPress={() => setHasDriverLicense(true)}
              >
                <Ionicons
                  name="checkmark-circle"
                  size={32}
                  color={hasDriverLicense ? COLORS.white : COLORS.primary}
                />
                <Text
                  style={[
                    styles.toggleText,
                    hasDriverLicense && styles.toggleTextActive,
                  ]}
                >
                  Yes, I have a license
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.toggleButton,
                  !hasDriverLicense && styles.toggleButtonActive,
                ]}
                onPress={() => setHasDriverLicense(false)}
              >
                <Ionicons
                  name="close-circle"
                  size={32}
                  color={!hasDriverLicense ? COLORS.white : COLORS.textSecondary}
                />
                <Text
                  style={[
                    styles.toggleText,
                    !hasDriverLicense && styles.toggleTextActive,
                  ]}
                >
                  No license
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        );

      default:
        return null;
    }
  };

  return (
    <View style={styles.container}>
      {renderProgressBar()}

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {renderStep()}
      </ScrollView>

      <View style={styles.buttonContainer}>
        {step > 1 && (
          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>Back</Text>
          </TouchableOpacity>
        )}

        <TouchableOpacity
          style={[styles.nextButton, step === 1 && styles.nextButtonFull]}
          onPress={handleNext}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.nextButtonText}>
              {step === totalSteps ? "Complete" : "Next"}
            </Text>
          )}
        </TouchableOpacity>
      </View>
    </View>
  );
}
```
</details>

**Features:**
- 5-step multi-step form with progress indicator
- Step 1: About/bio text area
- Step 2: Address and nationality input
- Step 3: Identity document and selfie photo upload
- Step 4: Multi-select for skills, languages, and traits
- Step 5: Driver license toggle
- Image picker integration with upload functionality
- Full validation at each step
- Calls POST /api/mobile/profile/job-seeker endpoint
- Updates user state with onboardingCompleted: true
- Redirects to tabs after completion

---

### 5. /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/assets/styles/onboarding.styles.js (NEW FILE)

<details>
<summary>View Complete Code</summary>

```javascript
import { StyleSheet, Dimensions } from "react-native";
import COLORS from "../../constants/colors";

const { width } = Dimensions.get("window");

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  progressContainer: {
    padding: 20,
    paddingTop: 60,
    backgroundColor: COLORS.cardBackground,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.border,
  },
  progressBar: {
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    marginBottom: 10,
  },
  progressDot: {
    width: 40,
    height: 6,
    borderRadius: 3,
    backgroundColor: COLORS.border,
    marginHorizontal: 4,
  },
  progressDotActive: {
    backgroundColor: COLORS.primary,
  },
  progressText: {
    textAlign: "center",
    color: COLORS.textSecondary,
    fontSize: 14,
    fontWeight: "500",
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  stepContainer: {
    flex: 1,
  },
  stepTitle: {
    fontSize: 28,
    fontWeight: "700",
    color: COLORS.textPrimary,
    marginBottom: 8,
  },
  stepSubtitle: {
    fontSize: 16,
    color: COLORS.textSecondary,
    marginBottom: 24,
    lineHeight: 22,
  },
  inputGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    marginBottom: 8,
    color: COLORS.textPrimary,
    fontWeight: "500",
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: COLORS.inputBackground,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: COLORS.border,
    paddingHorizontal: 12,
  },
  inputIcon: {
    marginRight: 10,
  },
  input: {
    flex: 1,
    height: 48,
    color: COLORS.textDark,
  },
  textArea: {
    backgroundColor: COLORS.inputBackground,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: COLORS.border,
    padding: 16,
    fontSize: 16,
    color: COLORS.textDark,
    minHeight: 150,
  },
  uploadSection: {
    marginBottom: 24,
  },
  uploadLabel: {
    fontSize: 16,
    fontWeight: "600",
    color: COLORS.textPrimary,
    marginBottom: 12,
  },
  uploadButton: {
    backgroundColor: COLORS.inputBackground,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: COLORS.border,
    borderStyle: "dashed",
    padding: 32,
    alignItems: "center",
    justifyContent: "center",
    minHeight: 180,
  },
  uploadText: {
    marginTop: 12,
    fontSize: 14,
    color: COLORS.textSecondary,
    fontWeight: "500",
  },
  previewImage: {
    width: "100%",
    height: "100%",
    borderRadius: 8,
  },
  selectionSection: {
    marginBottom: 24,
  },
  selectionLabel: {
    fontSize: 16,
    fontWeight: "600",
    color: COLORS.textPrimary,
    marginBottom: 12,
  },
  chipContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  chip: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    backgroundColor: COLORS.inputBackground,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  chipSelected: {
    backgroundColor: COLORS.primary,
    borderColor: COLORS.primary,
  },
  chipText: {
    fontSize: 14,
    color: COLORS.textPrimary,
    fontWeight: "500",
  },
  chipTextSelected: {
    color: COLORS.white,
  },
  toggleContainer: {
    marginTop: 32,
  },
  toggleButton: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: COLORS.inputBackground,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: COLORS.border,
    padding: 20,
    marginBottom: 16,
  },
  toggleButtonActive: {
    backgroundColor: COLORS.primary,
    borderColor: COLORS.primary,
  },
  toggleText: {
    marginLeft: 16,
    fontSize: 16,
    fontWeight: "600",
    color: COLORS.textPrimary,
  },
  toggleTextActive: {
    color: COLORS.white,
  },
  buttonContainer: {
    flexDirection: "row",
    padding: 20,
    paddingBottom: 40,
    backgroundColor: COLORS.cardBackground,
    borderTopWidth: 1,
    borderTopColor: COLORS.border,
    gap: 12,
  },
  backButton: {
    flex: 1,
    backgroundColor: COLORS.inputBackground,
    borderRadius: 12,
    height: 50,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  backButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  nextButton: {
    flex: 2,
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    height: 50,
    justifyContent: "center",
    alignItems: "center",
    shadowColor: COLORS.black,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  nextButtonFull: {
    flex: 1,
  },
  nextButtonText: {
    color: COLORS.white,
    fontSize: 16,
    fontWeight: "600",
  },
});

export default styles;
```
</details>

**Styling Features:**
- Progress bar with dots at top
- Responsive layout for all screen sizes
- Proper spacing and padding throughout
- Upload button with dashed border
- Multi-select chips with active states
- Toggle buttons for yes/no questions
- Button container at bottom with back/next buttons
- Follows FOREST/JOB theme colors from existing app

---

### 6. Update /Users/hoangpham/dev/github/burakorkmez/bookworm-expo/mobile/app/_layout.jsx

The root layout needs to be updated to handle the onboarding route:

<details>
<summary>View Updated Code</summary>

```jsx
import { SplashScreen, Stack, useRouter, useSegments } from "expo-router";
import { SafeAreaProvider } from "react-native-safe-area-context";
import SafeScreen from "../components/SafeScreen";
import { StatusBar } from "expo-status-bar";
import { useFonts } from "expo-font";

import { useAuthStore } from "../store/authStore";
import { useEffect } from "react";

SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const router = useRouter();
  const segments = useSegments();

  const { checkAuth, user, accessToken } = useAuthStore();

  const [fontsLoaded] = useFonts({
    "JetBrainsMono-Medium": require("../assets/fonts/JetBrainsMono-Medium.ttf"),
  });

  useEffect(() => {
    if (fontsLoaded) SplashScreen.hideAsync();
  }, [fontsLoaded]);

  useEffect(() => {
    checkAuth();
  }, []);

  // Handle navigation based on auth state and onboarding status
  useEffect(() => {
    const inAuthScreen = segments[0] === "(auth)";
    const isSignedIn = user && accessToken;

    if (!isSignedIn && !inAuthScreen) {
      router.replace("/(auth)");
    } else if (isSignedIn && !inAuthScreen) {
      // User is signed in but not in auth screens
      // If they need onboarding, it will be handled in the login/signup screens
      router.replace("/(tabs)");
    }
  }, [user, accessToken, segments]);

  return (
    <SafeAreaProvider>
      <SafeScreen>
        <Stack screenOptions={{ headerShown: false }}>
          <Stack.Screen name="(tabs)" />
          <Stack.Screen name="(auth)" />
        </Stack>
      </SafeScreen>
      <StatusBar style="dark" />
    </SafeAreaProvider>
  );
}
```
</details>

**Key Changes:**
- Updated to use `accessToken` instead of `token`
- Simplified navigation logic (onboarding routing is handled in login/signup screens)

---

## Backend API Implementation

You'll need to create these API endpoints in the joob backend. Here's a summary of what each endpoint should do:

### 1. POST /api/mobile/auth/register

**Request:**
```json
{
  "firstName": "John",
  "lastName": "Doe",
  "email": "john@example.com",
  "password": "password123"
}
```

**Response:**
```json
{
  "user": {
    "id": "user_id",
    "email": "john@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "name": "John Doe",
    "userType": "USER",
    "onboardingCompleted": false
  },
  "accessToken": "jwt_access_token",
  "refreshToken": "jwt_refresh_token",
  "expiresIn": 3600
}
```

### 2. POST /api/mobile/auth/login

**Request:**
```json
{
  "email": "john@example.com",
  "password": "password123"
}
```

**Response:**
```json
{
  "user": {
    "id": "user_id",
    "email": "john@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "name": "John Doe",
    "userType": "JOB_SEEKER",
    "onboardingCompleted": true
  },
  "accessToken": "jwt_access_token",
  "refreshToken": "jwt_refresh_token",
  "expiresIn": 3600
}
```

### 3. POST /api/mobile/auth/refresh

**Request:**
```json
{
  "refreshToken": "jwt_refresh_token"
}
```

**Response:**
```json
{
  "accessToken": "new_jwt_access_token",
  "expiresIn": 3600
}
```

### 4. GET /api/mobile/auth/me

**Headers:**
```
Authorization: Bearer jwt_access_token
```

**Response:**
```json
{
  "user": {
    "id": "user_id",
    "email": "john@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "name": "John Doe",
    "userType": "JOB_SEEKER",
    "onboardingCompleted": true
  },
  "expiresIn": 3600
}
```

### 5. POST /api/mobile/profile/job-seeker

**Headers:**
```
Authorization: Bearer jwt_access_token
```

**Request:**
```json
{
  "email": "john@example.com",
  "about": "I am a hardworking...",
  "address": "123 Main St, Berlin, 10115",
  "nationality": "German",
  "identityVerification": "https://url-to-id-doc",
  "selfiePhoto": "https://url-to-selfie",
  "skills": ["Customer Service", "Sales"],
  "languages": ["English", "German"],
  "traits": ["Reliable", "Punctual"],
  "hasDriverLicense": true
}
```

**Response:**
```json
{
  "success": true,
  "message": "Job seeker profile created successfully",
  "jobSeeker": {
    "id": "jobseeker_id",
    "userId": "user_id",
    ...profile_data
  }
}
```

---

## Summary

This implementation provides:

1. **Complete Auth Flow**: Registration, login, token refresh, and auth checking
2. **Automatic Token Refresh**: Tokens refresh 15 minutes before expiry
3. **Onboarding Flow**: 5-step onboarding for job seekers with validation
4. **Clean UI**: Maintains the existing FOREST/JOB theme
5. **Error Handling**: Proper error messages and loading states
6. **Navigation Logic**: Automatically redirects based on onboarding status
7. **Image Upload**: Identity verification with document and selfie upload
8. **Multi-Select**: Skills, languages, and traits selection
9. **Production-Ready**: Proper validation, error handling, and user feedback

All files maintain the existing UI style and follow React Native best practices with proper state management, async operations, and user feedback through alerts and loading indicators.
